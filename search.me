No estudo de programação competitiva, os algoritmos de busca são fundamentais para resolver uma ampla gama de problemas. Aqui está uma lista dos principais algoritmos e métodos de busca usados na área:


---

1. Busca Linear

Descrição: Percorre todos os elementos de uma lista sequencialmente até encontrar o elemento desejado.

Complexidade: .

Uso Comum: Pequenas entradas ou quando a estrutura de dados não é ordenada.



---

2. Busca Binária

Descrição: Divide a busca pela metade em cada iteração em uma lista ordenada.

Complexidade: .

Uso Comum: Problemas envolvendo arrays ou intervalos ordenados.

Variante: Busca Binária em Resposta (usada para encontrar o menor/maior valor que satisfaz uma condição).



---

3. Busca Ternária

Descrição: Similar à busca binária, mas divide a busca em três partes. Usada principalmente para funções unimodais.

Complexidade: .

Uso Comum: Otimização de funções unimodais (ex: encontrar o ponto mínimo/máximo).



---

4. Busca por Exaustão (Backtracking)

Descrição: Explora todas as possibilidades de solução, voltando atrás quando necessário.

Complexidade: , onde  é o fator de ramificação e  é a profundidade da solução.

Uso Comum: Problemas de caminhos (ex: Sudoku, quebra-cabeças).



---

5. Busca em Largura (BFS - Breadth-First Search)

Descrição: Explora nível por nível em um grafo ou árvore.

Complexidade: , onde  é o número de vértices e  o número de arestas.

Uso Comum: Caminho mais curto em grafos não ponderados.



---

6. Busca em Profundidade (DFS - Depth-First Search)

Descrição: Explora o grafo ou árvore seguindo um caminho até o fim antes de retroceder.

Complexidade: .

Uso Comum: Detecção de ciclos, componentes conectados e problemas de busca exaustiva.



---

7. Busca A (A Star)*

Descrição: Algoritmo heurístico que combina custo do caminho percorrido e uma estimativa do custo até o destino.

Complexidade: Depende da heurística ( no pior caso).

Uso Comum: Jogos e problemas de caminho em grafos (ex: mapas).



---

8. Busca Gulosa (Greedy Search)

Descrição: Escolhe sempre a melhor opção local em cada etapa.

Complexidade: Variável.

Uso Comum: Otimização de rotas, problemas de grafos (ex: algoritmo de Prim ou Kruskal).



---

9. Busca Binária no Grafo

Descrição: Combina busca binária com BFS/DFS para encontrar o menor valor que satisfaz uma condição em grafos ponderados.

Complexidade: , onde  é o maior peso.

Uso Comum: Problemas que envolvem pesos em grafos.



---

10. Busca Iterativa Limitada em Profundidade

Descrição: Combina DFS com um limite de profundidade, aumentando o limite iterativamente.

Complexidade: .

Uso Comum: Solução de problemas com limites de profundidade definidos.



---

11. Busca Simulada (Simulated Annealing)

Descrição: Algoritmo probabilístico usado para encontrar soluções aproximadas para problemas de otimização.

Complexidade: Depende da configuração do algoritmo.

Uso Comum: Problemas de otimização complexos.



---

Esses algoritmos são amplamente usados em competições de programação, como o Codeforces, AtCoder e Google Code Jam, e variam de acordo com o problema. Estudar suas implementações e aplicações práticas é essencial para obter bons resultados.

